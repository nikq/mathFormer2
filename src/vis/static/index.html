<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MathFormer2 Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-color: #e2e8f0;
            --accent-color: #38bdf8;
            --secondary-color: #94a3b8;
            --font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 300px auto 1fr;
            gap: 20px;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .card-header {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 10px;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        #metrics-panel {
            grid-column: 1 / -1;
            grid-row: 1;
        }

        #weights-panel {
            grid-column: 1;
            grid-row: 3;
        }

        #attention-panel {
            grid-column: 2;
            grid-row: 3;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-color);
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--secondary-color);
        }

        /* D3 Styles */
        .line {
            fill: none;
            stroke: var(--accent-color);
            stroke-width: 2;
        }

        .heatmap-rect {
            transition: fill 0.2s;
        }

        .axis text {
            fill: var(--secondary-color);
            font-size: 10px;
        }

        .axis path,
        .axis line {
            stroke: var(--secondary-color);
            opacity: 0.2;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-group label {
            font-size: 10px;
            color: var(--secondary-color);
            text-transform: uppercase;
        }

        .control-group input {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--secondary-color);
            color: var(--text-color);
            padding: 4px 8px;
            border-radius: 4px;
            width: 60px;
        }

        .layer-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .layer-label {
            width: 30px;
            font-size: 12px;
            font-weight: bold;
            color: var(--accent-color);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            text-align: center;
        }

        .weight-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .weight-title {
            font-size: 10px;
            color: var(--secondary-color);
            margin-bottom: 4px;
        }

        #embeddings-panel {
            grid-column: 1 / -1;
            grid-row: 4;
        }
    </style>
</head>

<body>
    <h1>MathFormer2 <span style="font-weight: 300; color: var(--secondary-color); font-size: 1rem;">Live Training</span>
    </h1>

    <div class="container">
        <div class="card" id="metrics-panel">
            <div class="card-header">Training Metrics</div>
            <div style="display: flex; gap: 40px; margin-bottom: 10px; align-items: flex-start;">
                <div>
                    <div class="metric-value">Step: <span id="step-display">0</span> | Loss: <span
                            id="loss-display">0.0000</span></div>
                    <div class="metric-value" style="font-size: 16px; margin-top: 10px;">
                        Input: <span id="input-sample" style="font-family: monospace; color: #cbd5e1;"></span><br>
                        Output: <span id="output-sample" style="font-family: monospace; color: #cbd5e1;"></span>
                    </div>
                </div>
                <div id="loss-chart" style="flex-grow: 1; height: 200px;"></div>
            </div>
        </div>

        <div class="card" id="control-panel"
            style="grid-column: 1 / -1; grid-row: 2; display: flex; flex-direction: row; gap: 20px; align-items: center; padding: 10px 20px;">
            <div class="card-header" style="margin-bottom: 0; margin-right: 20px;">Control Panel</div>

            <div class="control-group">
                <label>Difficulty</label>
                <input type="number" id="cfg-difficulty" value="1" min="1" max="10" onchange="updateDifficulty()">
            </div>
            <div class="control-group">
                <label>Layers</label>
                <input type="number" id="cfg-layers" value="4" min="1" max="12">
            </div>
            <div class="control-group">
                <label>Heads</label>
                <input type="number" id="cfg-heads" value="4" min="1" max="12">
            </div>
            <div class="control-group">
                <label>D_Model</label>
                <input type="number" id="cfg-dmodel" value="128" step="16" min="16">
            </div>

            <button onclick="restartTraining()"
                style="margin-left: auto; background: var(--accent-color); border: none; padding: 8px 16px; border-radius: 6px; color: #0f172a; font-weight: bold; cursor: pointer;">Restart
                Training</button>
        </div>

        <div class="card" id="weights-panel">
            <div class="card-header">Model Weights</div>
            <div id="weights-grid"></div>
        </div>

        <div class="card" id="attention-panel">
            <div class="card-header">Attention Patterns</div>
            <div id="attn-grid"
                style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;"></div>
        </div>

        <div class="card" id="embeddings-panel">
            <div class="card-header">Embeddings</div>
            <div style="display: flex; gap: 20px;">
                <div style="flex: 1;">
                    <div class="weight-title">Token Embeddings</div>
                    <div id="token-emb-vis" style="height: 150px; width: 100%;"></div>
                </div>
                <div style="flex: 1;">
                    <div class="weight-title">Position Embeddings</div>
                    <div id="pos-emb-vis" style="height: 150px; width: 100%;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const ws = new WebSocket(`ws://${window.location.host}/ws`);

        // Setup D3 Charts
        const margin = { top: 10, right: 10, bottom: 20, left: 30 };

        // Loss Chart
        const lossContainer = d3.select("#loss-chart");

        ws.onmessage = function (event) {
            const data = JSON.parse(event.data);
            updateDashboard(data);
        };

        function updateDashboard(data) {
            // Update Metrics
            document.getElementById("step-display").innerText = data.metrics.step;
            const currentLoss = data.metrics.loss.length > 0 ? data.metrics.loss[data.metrics.loss.length - 1].value : 0;
            document.getElementById("loss-display").innerText = currentLoss.toFixed(4);

            if (data.weights && data.weights.data_sample) {
                document.getElementById("input-sample").innerText = data.weights.data_sample.input;
                document.getElementById("output-sample").innerText = data.weights.data_sample.output;
            }

            renderLossChart(data.metrics.loss);

            if (data.weights) {
                if (data.weights.layer_weights) renderAllWeights(data.weights.layer_weights);
                if (data.weights.attention) renderAttention(data.weights.attention);
                if (data.weights.embeddings) renderEmbeddings(data.weights.embeddings);
            }
        }

        function renderEmbeddings(embeddings) {
            if (embeddings.token) {
                const canvas = document.createElement("canvas");
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                const container = document.getElementById("token-emb-vis");
                container.innerHTML = '';
                container.appendChild(canvas);
                renderHeatmapOnCanvas(canvas, embeddings.token);
            }
            if (embeddings.position) {
                const canvas = document.createElement("canvas");
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                const container = document.getElementById("pos-emb-vis");
                container.innerHTML = '';
                container.appendChild(canvas);
                renderHeatmapOnCanvas(canvas, embeddings.position);
            }
        }

        function renderLossChart(lossData) {
            const container = document.getElementById("loss-chart");
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            lossContainer.selectAll("*").remove();

            const svg = lossContainer.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain([0, d3.max(lossData, d => d.step) || 100])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(lossData, d => d.value) || 1])
                .range([height, 0]);

            svg.append("path")
                .datum(lossData)
                .attr("class", "line")
                .attr("d", d3.line()
                    .x(d => x(d.step))
                    .y(d => y(d.value))
                );

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .attr("class", "axis")
                .call(d3.axisBottom(x).ticks(5));

            svg.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y).ticks(5));
        }

        function renderAllWeights(allWeights) {
            const container = document.getElementById("weights-grid");
            container.innerHTML = '';

            // Group weights by layer
            const layers = {};
            const otherWeights = {};

            Object.keys(allWeights).forEach(key => {
                const match = key.match(/transformer\.h\.(\d+)\.(.+)/);
                if (match) {
                    const layerIdx = parseInt(match[1]);
                    const weightType = match[2];
                    if (!layers[layerIdx]) layers[layerIdx] = {};
                    layers[layerIdx][weightType] = allWeights[key];
                } else {
                    otherWeights[key] = allWeights[key];
                }
            });

            // Render Layers
            Object.keys(layers).sort((a, b) => a - b).forEach(layerIdx => {
                const layerData = layers[layerIdx];
                const row = document.createElement("div");
                row.className = "layer-row";

                const label = document.createElement("div");
                label.className = "layer-label";
                label.innerText = `L${layerIdx}`;
                row.appendChild(label);

                container.appendChild(row); // Append row to DOM first

                // Define order of weights in a layer
                const weightOrder = [
                    { key: 'attn.c_attn.weight', label: 'QKV' },
                    { key: 'attn.c_proj.weight', label: 'Attn Proj' },
                    { key: 'mlp.c_fc.weight', label: 'MLP FC' },
                    { key: 'mlp.c_proj.weight', label: 'MLP Proj' }
                ];

                weightOrder.forEach(w => {
                    if (layerData[w.key]) {
                        const group = document.createElement("div");
                        group.className = "weight-group";

                        const title = document.createElement("div");
                        title.className = "weight-title";
                        title.innerText = w.label;
                        group.appendChild(title);

                        const canvasContainer = document.createElement("div");
                        canvasContainer.style.width = "100px";
                        canvasContainer.style.height = "100px";
                        canvasContainer.style.backgroundColor = "rgba(0,0,0,0.2)";

                        const canvas = document.createElement("canvas");
                        canvas.style.width = "100%";
                        canvas.style.height = "100%";
                        canvasContainer.appendChild(canvas);
                        group.appendChild(canvasContainer);

                        row.appendChild(group); // Append group to row (which is in DOM)

                        // Now render, canvas is in DOM
                        renderHeatmapOnCanvas(canvas, layerData[w.key]);
                    }
                });
            });

            // Render Other Weights (Embeddings, Head, etc)
            const otherRow = document.createElement("div");
            otherRow.className = "layer-row";
            otherRow.style.flexWrap = "wrap";

            if (Object.keys(otherWeights).length > 0) {
                const label = document.createElement("div");
                label.className = "layer-label";
                label.innerText = "MISC";
                otherRow.insertBefore(label, otherRow.firstChild);
                container.appendChild(otherRow); // Append to DOM first
            }

            Object.keys(otherWeights).sort().forEach(key => {
                const group = document.createElement("div");
                group.className = "weight-group";

                const title = document.createElement("div");
                title.className = "weight-title";
                title.innerText = key.split('.').pop(); // Simple name
                title.title = key; // Full name on hover
                group.appendChild(title);

                const canvasContainer = document.createElement("div");
                canvasContainer.style.width = "100px";
                canvasContainer.style.height = "100px";
                canvasContainer.style.backgroundColor = "rgba(0,0,0,0.2)";

                const canvas = document.createElement("canvas");
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvasContainer.appendChild(canvas);
                group.appendChild(canvasContainer);

                otherRow.appendChild(group);

                renderHeatmapOnCanvas(canvas, otherWeights[key]);
            });
        }

        function renderHeatmapOnCanvas(canvas, data) {
            // Handle 1D (bias) vs 2D (weight)
            let matrix = data;
            if (!Array.isArray(data)) {
                console.warn("Invalid data passed to renderHeatmapOnCanvas", data);
                return;
            }
            if (!Array.isArray(data[0])) {
                // 1D array -> make it 1xN matrix for visualization
                matrix = [data];
            }

            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                console.warn("Canvas has 0 dimensions", rect, canvas);
            }
            canvas.width = rect.width;
            canvas.height = rect.height;
            const ctx = canvas.getContext("2d");

            const rows = matrix.length;
            const cols = matrix[0].length;
            const cellWidth = canvas.width / cols;
            const cellHeight = canvas.height / rows;

            // Find min/max
            let min = Infinity, max = -Infinity;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const v = matrix[r][c];
                    if (typeof v !== 'number' || isNaN(v)) continue;
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
            }

            // Avoid div by zero or invalid range
            if (!isFinite(min) || !isFinite(max)) {
                // Render blank or error state
                ctx.fillStyle = "#333";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }

            if (max === min) max = min + 1e-9;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const val = matrix[r][c];
                    if (typeof val !== 'number' || isNaN(val)) {
                        ctx.fillStyle = "#f00"; // Red for error
                    } else {
                        const norm = (val - min) / (max - min);
                        // Heatmap coloring using just gray
                        const intensity = Math.floor(norm * 255);
                        ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    }
                    // Use simple rects
                    ctx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                }
            }
        }

        function renderAttention(allAttn) {
            const grid = document.getElementById("attn-grid");
            grid.innerHTML = ''; // Clear existing

            // Check if we need to build structure (similar to weights)
            const keys = Object.keys(allAttn).sort((a, b) => {
                // Sort by Layer then Head. Format: "L{i}.H{h}"
                const parse = s => {
                    const parts = s.split('.');
                    const l = parseInt(parts[0].substring(1));
                    const h = parseInt(parts[1].substring(1));
                    return [l, h];
                };
                const [l1, h1] = parse(a);
                const [l2, h2] = parse(b);
                if (l1 !== l2) return l1 - l2;
                return h1 - h2;
            });

            keys.forEach(key => {
                const attnData = allAttn[key];

                const item = document.createElement("div");
                item.className = "attn-item";
                item.style.display = "flex";
                item.style.flexDirection = "column";
                item.style.height = "200px";
                item.style.backgroundColor = "rgba(0,0,0,0.2)";
                item.style.borderRadius = "8px";
                item.style.padding = "5px";

                const label = document.createElement("div");
                label.innerText = key;
                label.style.fontSize = "10px";
                label.style.marginBottom = "5px";
                label.style.color = "#94a3b8";
                item.appendChild(label);

                const canvasContainer = document.createElement("div");
                canvasContainer.style.flexGrow = "1";
                canvasContainer.style.position = "relative";
                item.appendChild(canvasContainer);

                const canvas = document.createElement("canvas");
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvasContainer.appendChild(canvas);

                grid.appendChild(item); // Append to DOM first

                renderHeatmapOnCanvas(canvas, attnData);
            });
        }

        async function restartTraining() {
            const difficulty = document.getElementById('cfg-difficulty').value;
            const layers = document.getElementById('cfg-layers').value;
            const heads = document.getElementById('cfg-heads').value;
            const dmodel = document.getElementById('cfg-dmodel').value;

            const config = {
                difficulty: parseInt(difficulty),
                n_layer: parseInt(layers),
                n_head: parseInt(heads),
                d_model: parseInt(dmodel)
            };

            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'restart',
                        config: config
                    })
                });

                if (response.ok) {
                    console.log('Restart command sent successfully');
                } else {
                    console.error('Failed to send restart command');
                }
            } catch (error) {
                console.error('Error sending restart command:', error);
            }
        }

        async function updateDifficulty() {
            const difficulty = document.getElementById('cfg-difficulty').value;

            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'update_difficulty',
                        config: { difficulty: parseInt(difficulty) }
                    })
                });

                if (response.ok) {
                    console.log('Difficulty update sent successfully');
                } else {
                    console.error('Failed to send difficulty update');
                }
            } catch (error) {
                console.error('Error sending difficulty update:', error);
            }
        }
    </script>
</body>

</html>